# Toddler's Bottle

![list](./img/list.png)

## List
- fd
- collsion
- bof
- flag
- passcode
- random
- input
- leg
- mistake
- shellshock   
- coin1
- blackjack
- lotto
- cmd1
- cmd2
- uaf
- memcpy
- asm
- unlink

## fd

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char buf[32];
int main(int argc, char* argv[], char* envp[]){
	if(argc<2){
		printf("pass argv[1] a number\n");
		return 0;
	}
	int fd = atoi( argv[1] ) - 0x1234;
	int len = 0;
	len = read(fd, buf, 32);
	if(!strcmp("LETMEWIN\n", buf)){
		printf("good job :)\n");
		system("/bin/cat flag");
		exit(0);
	}
	printf("learn about Linux file IO\n");
	return 0;

}
```
다음같은 코드가 주어진다.

| fd | action |
|:--------|:--------|
| 0  | stdin |
| 1  | stdout |
| 2  | stderr |
| 3~ | File |

fd는 다음과 같이 이루어진다. 따라서 read시 fd값을 우리가 조절할 수 있으므로, 이를 0으로 만들어 stdin으로 input을 받으면, buf에 원하는 값을 넣을 수 있을것이다.

![fd](./img/fd.png)

__Flag__ : mommy! I think I know what a file descriptor is!!

## collision

```
#include <stdio.h>
#include <string.h>
unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i<5; i++){
		res += ip[i];
	}
	return res;
}

int main(int argc, char* argv[]){
	if(argc<2){
		printf("usage : %s [passcode]\n", argv[0]);
		return 0;
	}
	if(strlen(argv[1]) != 20){
		printf("passcode length should be 20 bytes\n");
		return 0;
	}

	if(hashcode == check_password( argv[1] )){
		system("/bin/cat flag");
		return 0;
	}
	else
		printf("wrong passcode.\n");
	return 0;
}
```
다음같은 코드가 주어진다.
길이다 20이여야 하고, hashcode된 값이 check_password(argv[1])의 값과 같아야한다.
단순하게 0x21DD09EC를 5로 나누어서 넣어주면 되는데, 4가 남으므로 마지막꺼에는 4를 더한값을 넣어주면 된다.

![collision](./img/collision.png)

__Flag__ : daddy! I just managed to create a hash collision :)

## bof

```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	// smash me!
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}
int main(int argc, char* argv[]){
	func(0xdeadbeef);
	return 0;
}

```
다음같은 코드가 주어진다.
overflowme에서 input을 받을때 gets를 써서 bof가 일어난다.
이를 통해서 key를 0xcafebabe로 덮어주면 된다.

![bof1](./img/bof1.png)

offset : 0x2c + 8 = 52

![bof2](./img/bof2.png)

__Flag__ : daddy, I just pwned a buFFer :)

## flag

리버싱문제라면서 바이너리만 준다.

![flag1](./img/flag1.png)

upx로 패킹되어있다고 하니 풀어주면 될거 같다.

![flag2](./img/flag2.png)

![flag2](./img/flag3.png)

__Flag__ : UPX...? sounds like a delivery service :)

## passcode

```
#include <stdio.h>
#include <stdlib.h>

void login(){
	int passcode1;
	int passcode2;

	printf("enter passcode1 : ");
	scanf("%d", passcode1);
	fflush(stdin);

	// ha! mommy told me that 32bit is vulnerable to bruteforcing :)
	printf("enter passcode2 : ");
    scanf("%d", passcode2);

	printf("checking...\n");
	if(passcode1==338150 && passcode2==13371337){
                printf("Login OK!\n");
                system("/bin/cat flag");
        }
        else{
                printf("Login Failed!\n");
		exit(0);
        }
}

void welcome(){
	char name[100];
	printf("enter you name : ");
	scanf("%100s", name);
	printf("Welcome %s!\n", name);
}

int main(){
	printf("Toddler's Secure Login System 1.0 beta.\n");

	welcome();
	login();

	// something after login...
	printf("Now I can safely trust you that you have credential :)\n");
	return 0;	
}
```
다음과 같은 코드를 준다.
보면 scanf를 받을때 &를 안적어서, 바로 주소에다가 적을 수 있다.
<br>그리고 name을 받는 함수 실행후에, scanf부분이 실행되는데, uninitialized stack이므로, 원하는 주소에 원하는 값을 쓸 수 있게 된다. <br>고로 exit의 got를 system("/bin/cat flag")의 주소로 바꿔주면 flag를 얻을 수 있다. %d로 받으니까 10진수로 바꿔주자.

![passcode](./img/passcode.png)
__Flag__ : Sorry mom.. I got confused about scanf usage :(

## random

```
#include <stdio.h>

int main(){
	unsigned int random;
	random = rand();	// random value!

	unsigned int key=0;
	scanf("%d", &key);

	if( (key ^ random) == 0xdeadbeef ){
		printf("Good!\n");
		system("/bin/cat flag");
		return 0;
	}

	printf("Wrong, maybe you should try 2^32 cases.\n");
	return 0;
}
```
srand없이 하는 rand는 값이 똑같다. gdb로 보면 rand값이 0x6b8b4567다.

따라서 0x6b8b4567 ^ 0xdeadbeef = 3039230856 이므로 저걸 넣어주면 끝난다.

![random](./img/random.png)

__Flag__ : Mommy, I thought libc random is unpredictable...

## input
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int main(int argc, char* argv[], char* envp[]){
	printf("Welcome to pwnable.kr\n");
	printf("Let's see if you know how to give input to program\n");
	printf("Just give me correct inputs then you will get the flag :)\n");

	// argv
	if(argc != 100) return 0;
	if(strcmp(argv['A'],"\x00")) return 0;
	if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0;
	printf("Stage 1 clear!\n");	

	// stdio
	char buf[4];
	read(0, buf, 4);
	if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0;
	read(2, buf, 4);
        if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0;
	printf("Stage 2 clear!\n");
	
	// env
	if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0;
	printf("Stage 3 clear!\n");

	// file
	FILE* fp = fopen("\x0a", "r");
	if(!fp) return 0;
	if( fread(buf, 4, 1, fp)!=1 ) return 0;
	if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0;
	fclose(fp);
	printf("Stage 4 clear!\n");	

	// network
	int sd, cd;
	struct sockaddr_in saddr, caddr;
	sd = socket(AF_INET, SOCK_STREAM, 0);
	if(sd == -1){
		printf("socket error, tell admin\n");
		return 0;
	}
	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = INADDR_ANY;
	saddr.sin_port = htons( atoi(argv['C']) );
	if(bind(sd, (struct sockaddr*)&saddr, sizeof(saddr)) < 0){
		printf("bind error, use another port\n");
    		return 1;
	}
	listen(sd, 1);
	int c = sizeof(struct sockaddr_in);
	cd = accept(sd, (struct sockaddr *)&caddr, (socklen_t*)&c);
	if(cd < 0){
		printf("accept error, tell admin\n");
		return 0;
	}
	if( recv(cd, buf, 4, 0) != 4 ) return 0;
	if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0;
	printf("Stage 5 clear!\n");

	// here's your flag
	system("/bin/cat flag");	
	return 0;
}
```
그냥 원하는거 맞춰서 넣어주면 된다.

[input.py](./exploit/input.py)
![input](./img/input.png)

__Flag__ : Mommy! I learned how to pass various input in Linux :)

## leg
```
int key1(){
	asm("mov r3, pc\n");
}
```
긴 코드라 필요한 부분만 보면, key1의 리턴은 mov r3, pc 이고, pc 는 i386에 eip랑 하는 일이 같다. 
```
(gdb) disass key1
Dump of assembler code for function key1:
   0x00008cd4 <+0>:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008cd8 <+4>:	add	r11, sp, #0
   0x00008cdc <+8>:	mov	r3, pc
   0x00008ce0 <+12>:	mov	r0, r3
   0x00008ce4 <+16>:	sub	sp, r11, #0
   0x00008ce8 <+20>:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008cec <+24>:	bx	lr
```
하지만 pc의 값은 arm은 pipeline을 사용하여 돌아감으로 pc는 현 실행 명령어 다음다음 명령어를 가르킨다.<br>따라서 key1의 값은 0x00008ce4 이다.

```
int key2(){
	asm(
	"push	{r6}\n"
	"add	r6, pc, $1\n"
	"bx	r6\n"
	".code   16\n"
	"mov	r3, pc\n"
	"add	r3, $0x4\n"
	"push	{r3}\n"
	"pop	{pc}\n"
	".code	32\n"
	"pop	{r6}\n"
	);
}
```
key2도 key1과 같다. 
```
(gdb) disass key2
Dump of assembler code for function key2:
   0x00008cf0 <+0>:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008cf4 <+4>:	add	r11, sp, #0
   0x00008cf8 <+8>:	push	{r6}		; (str r6, [sp, #-4]!)
   0x00008cfc <+12>:	add	r6, pc, #1
   0x00008d00 <+16>:	bx	r6
   0x00008d04 <+20>:	mov	r3, pc
   0x00008d06 <+22>:	adds	r3, #4
   0x00008d08 <+24>:	push	{r3}
   0x00008d0a <+26>:	pop	{pc}
   0x00008d0c <+28>:	pop	{r6}		; (ldr r6, [sp], #4)
   0x00008d10 <+32>:	mov	r0, r3
   0x00008d14 <+36>:	sub	sp, r11, #0
   0x00008d18 <+40>:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008d1c <+44>:	bx	lr
```
key2 : 0x00008d08 + 4

```
int key3(){
	asm("mov r3, lr\n");
}
```
lr은 return될 주소를 가르킨다. 
```
   0x00008d7c <+64>:	bl	0x8d20 <key3>
   0x00008d80 <+68>:	mov	r3, r0
```
key3 : 0x00008d80 

따라서 답은 108400다.

![leg](./img/leg.png)

__Flag__ : My daddy has a lot of ARMv5te muscle!

## mistake
```
#include <stdio.h>
#include <fcntl.h>

#define PW_LEN 10
#define XORKEY 1

void xor(char* s, int len){
	int i;
	for(i=0; i<len; i++){
		s[i] ^= XORKEY;
	}
}

int main(int argc, char* argv[]){
	
	int fd;
	if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
		printf("can't open password %d\n", fd);
		return 0;
	}

	printf("do not bruteforce...\n");
	sleep(time(0)%20);

	char pw_buf[PW_LEN+1];
	int len;
	if(!(len=read(fd,pw_buf,PW_LEN) > 0)){
		printf("read error\n");
		close(fd);
		return 0;		
	}

	char pw_buf2[PW_LEN+1];
	printf("input password : ");
	scanf("%10s", pw_buf2);

	// xor your input
	xor(pw_buf2, 10);

	if(!strncmp(pw_buf, pw_buf2, PW_LEN)){
		printf("Password OK\n");
		system("/bin/cat flag\n");
	}
	else{
		printf("Wrong Password\n");
	}

	close(fd);
	return 0;
}
```
인데 비교연산자는 대입우선자보다 우선순위가 높다.
```
if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0)
```
이부분에서, open의 return값은 에러가 뜨지 않는한 양수이고, 양수 < 0이 false이므로 fd = 0가 되고, 그러면 내가 원하는 값을 넣을 수 있다.

![mistake1](./img/mistake1.png)

![mistake2](./img/mistake2.png)

__Flag__ : Mommy, the operator priority always confuses me :(

## shellshock
```
#include <stdio.h>
int main(){
	setresuid(getegid(), getegid(), getegid());
	setresgid(getegid(), getegid(), getegid());
	system("/home/shellshock/bash -c 'echo shock_me'");
	return 0;
}
```
shellshock은 CVE-2014-6271에 등록된 bash취약점이다.

![shellshock](./img/shellshock1.png)
다음같이 검증해볼 수 있다. 원래는 실행되지 않아야할 echo vulnerable이 실행이 된것이다.

![shellshock](./img/shellshock2.png)

__Flag__ : only if I knew CVE-2014-6271 ten years ago..!!

## coin1
이진탐색을 짜주면 된다.

[coin.py](./exploit/coin.py)

![coin](./img/coin.png)

__Flag__ : b1NaRy_S34rch1nG_1s_3asy_p3asy

## blackjack
코드 오디팅을 하다보면
```
int betting() //Asks user amount to bet
{
 printf("\n\nEnter Bet: $");
 scanf("%d", &bet);
 
 if (bet > cash) //If player tries to bet more money than player has
 {
        printf("\nYou cannot bet more money than you have.");
        printf("\nEnter Bet: ");
        scanf("%d", &bet);
        return bet;
 }
 else return bet;
} // End Function
```
이러한 함수를 볼 수 있는데, bet가 음수인지는 체크하지 않는다.
```
if(p>21) //If player total is over 21, loss
{
    printf("\nWoah Buddy, You Went WAY over.\n");
    loss = loss+1;
    cash = cash - bet;
	printf("\nYou have %d Wins and %d Losses. Awesome!\n", won, loss);
    dealer_total=0;
    askover();
}
```
그리고 게임을 지게 되면 cash = cash - bet부분에 따라 bet가 음수이면 값이 더해지게 된다. 이를 이용해서 cash를 높이면 된다.

Betting할때 금액을 -10000000000정도를 넣고, 계속 Hit해서 지면된다.

![blackjack](./img/blackjack.png)

__Flag__ : YaY_I_AM_A_MILLIONARE_LOL

## lotto
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

unsigned char submit[6];

void play(){
	
	int i;
	printf("Submit your 6 lotto bytes : ");
	fflush(stdout);

	int r;
	r = read(0, submit, 6);

	printf("Lotto Start!\n");
	//sleep(1);

	// generate lotto numbers
	int fd = open("/dev/urandom", O_RDONLY);
	if(fd==-1){
		printf("error. tell admin\n");
		exit(-1);
	}
	unsigned char lotto[6];
	if(read(fd, lotto, 6) != 6){
		printf("error2. tell admin\n");
		exit(-1);
	}
	for(i=0; i<6; i++){
		lotto[i] = (lotto[i] % 45) + 1;		// 1 ~ 45
	}
	close(fd);
	
	// calculate lotto score
	int match = 0, j = 0;
	for(i=0; i<6; i++){
		for(j=0; j<6; j++){
			if(lotto[i] == submit[j]){
				match++;
			}
		}
	}

	// win!
	if(match == 6){
		system("/bin/cat flag");
	}
	else{
		printf("bad luck...\n");
	}

}

void help(){
	printf("- nLotto Rule -\n");
	printf("nlotto is consisted with 6 random natural numbers less than 46\n");
	printf("your goal is to match lotto numbers as many as you can\n");
	printf("if you win lottery for *1st place*, you will get reward\n");
	printf("for more details, follow the link below\n");
	printf("http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\n\n");
	printf("mathematical chance to win this game is known to be 1/8145060.\n");
}

int main(int argc, char* argv[]){

	// menu
	unsigned int menu;

	while(1){

		printf("- Select Menu -\n");
		printf("1. Play Lotto\n");
		printf("2. Help\n");
		printf("3. Exit\n");

		scanf("%d", &menu);

		switch(menu){
			case 1:
				play();
				break;
			case 2:
				help();
				break;
			case 3:
				printf("bye\n");
				return 0;
			default:
				printf("invalid menu\n");
				break;
		}
	}
	return 0;
}
```
로또값의 중복체크를 안한다.

그래서 그냥 !!!!!!를 계속 넣어주면된다. ( 로또번호가 1 ~ 45 )

![lotto](./img/lotto.png)

__Flag__ : sorry mom... I FORGOT to check duplicate numbers... :(

