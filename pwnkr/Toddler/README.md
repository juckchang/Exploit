# Toddler's Bottle

![list](./img/list.png)

## List
- fd
- collsion
- bof
- flag
- passcode
- random
- input
- leg
- mistake
- shellshock   
- coin1
- blackjack
- lotto
- cmd1
- cmd2
- uaf
- memcpy
- asm
- unlink

## fd

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char buf[32];
int main(int argc, char* argv[], char* envp[]){
	if(argc<2){
		printf("pass argv[1] a number\n");
		return 0;
	}
	int fd = atoi( argv[1] ) - 0x1234;
	int len = 0;
	len = read(fd, buf, 32);
	if(!strcmp("LETMEWIN\n", buf)){
		printf("good job :)\n");
		system("/bin/cat flag");
		exit(0);
	}
	printf("learn about Linux file IO\n");
	return 0;

}
```
다음같은 코드가 주어진다.

| fd | action |
|:--------|:--------|
| 0  | stdin |
| 1  | stdout |
| 2  | stderr |
| 3~ | File |

fd는 다음과 같이 이루어진다. 따라서 read시 fd값을 우리가 조절할 수 있으므로, 이를 0으로 만들어 stdin으로 input을 받으면, buf에 원하는 값을 넣을 수 있을것이다.

![fd](./img/fd.png)

__Flag__ : mommy! I think I know what a file descriptor is!!

## collision

```
#include <stdio.h>
#include <string.h>
unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
	int* ip = (int*)p;
	int i;
	int res=0;
	for(i=0; i<5; i++){
		res += ip[i];
	}
	return res;
}

int main(int argc, char* argv[]){
	if(argc<2){
		printf("usage : %s [passcode]\n", argv[0]);
		return 0;
	}
	if(strlen(argv[1]) != 20){
		printf("passcode length should be 20 bytes\n");
		return 0;
	}

	if(hashcode == check_password( argv[1] )){
		system("/bin/cat flag");
		return 0;
	}
	else
		printf("wrong passcode.\n");
	return 0;
}
```
다음같은 코드가 주어진다.
길이다 20이여야 하고, hashcode된 값이 check_password(argv[1])의 값과 같아야한다.
단순하게 0x21DD09EC를 5로 나누어서 넣어주면 되는데, 4가 남으므로 마지막꺼에는 4를 더한값을 넣어주면 된다.

![collision](./img/collision.png)

__Flag__ : daddy! I just managed to create a hash collision :)

## bof

```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void func(int key){
	char overflowme[32];
	printf("overflow me : ");
	gets(overflowme);	// smash me!
	if(key == 0xcafebabe){
		system("/bin/sh");
	}
	else{
		printf("Nah..\n");
	}
}
int main(int argc, char* argv[]){
	func(0xdeadbeef);
	return 0;
}

```
다음같은 코드가 주어진다.
overflowme에서 input을 받을때 gets를 써서 bof가 일어난다.
이를 통해서 key를 0xcafebabe로 덮어주면 된다.

![bof1](./img/bof1.png)

offset : 0x2c + 8 = 52

![bof2](./img/bof2.png)

__Flag__ : daddy, I just pwned a buFFer :)

## flag

리버싱문제라면서 바이너리만 준다.

![flag1](./img/flag1.png)

upx로 패킹되어있다고 하니 풀어주면 될거 같다.

![flag2](./img/flag2.png)

![flag2](./img/flag3.png)

__Flag__ : UPX...? sounds like a delivery service :)

## passcode

```
#include <stdio.h>
#include <stdlib.h>

void login(){
	int passcode1;
	int passcode2;

	printf("enter passcode1 : ");
	scanf("%d", passcode1);
	fflush(stdin);

	// ha! mommy told me that 32bit is vulnerable to bruteforcing :)
	printf("enter passcode2 : ");
    scanf("%d", passcode2);

	printf("checking...\n");
	if(passcode1==338150 && passcode2==13371337){
                printf("Login OK!\n");
                system("/bin/cat flag");
        }
        else{
                printf("Login Failed!\n");
		exit(0);
        }
}

void welcome(){
	char name[100];
	printf("enter you name : ");
	scanf("%100s", name);
	printf("Welcome %s!\n", name);
}

int main(){
	printf("Toddler's Secure Login System 1.0 beta.\n");

	welcome();
	login();

	// something after login...
	printf("Now I can safely trust you that you have credential :)\n");
	return 0;	
}
```
다음과 같은 코드를 준다.
보면 scanf를 받을때 &를 안적어서, 바로 주소에다가 적을 수 있다.
<br>그리고 name을 받는 함수 실행후에, scanf부분이 실행되는데, uninitialized stack이므로, 원하는 주소에 원하는 값을 쓸 수 있게 된다. <br>고로 exit의 got를 system("/bin/cat flag")의 주소로 바꿔주면 flag를 얻을 수 있다. %d로 받으니까 10진수로 바꿔주자.

![passcode](./img/passcode.png)
__Flag__ : Sorry mom.. I got confused about scanf usage :(

## random

```
#include <stdio.h>

int main(){
	unsigned int random;
	random = rand();	// random value!

	unsigned int key=0;
	scanf("%d", &key);

	if( (key ^ random) == 0xdeadbeef ){
		printf("Good!\n");
		system("/bin/cat flag");
		return 0;
	}

	printf("Wrong, maybe you should try 2^32 cases.\n");
	return 0;
}
```
srand없이 하는 rand는 값이 똑같다. gdb로 보면 rand값이 0x6b8b4567다.

따라서 0x6b8b4567 ^ 0xdeadbeef = 3039230856 이므로 저걸 넣어주면 끝난다.

![random](./img/random.png)

__Flag__ : Mommy, I thought libc random is unpredictable...

## input
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int main(int argc, char* argv[], char* envp[]){
	printf("Welcome to pwnable.kr\n");
	printf("Let's see if you know how to give input to program\n");
	printf("Just give me correct inputs then you will get the flag :)\n");

	// argv
	if(argc != 100) return 0;
	if(strcmp(argv['A'],"\x00")) return 0;
	if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0;
	printf("Stage 1 clear!\n");	

	// stdio
	char buf[4];
	read(0, buf, 4);
	if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0;
	read(2, buf, 4);
        if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0;
	printf("Stage 2 clear!\n");
	
	// env
	if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0;
	printf("Stage 3 clear!\n");

	// file
	FILE* fp = fopen("\x0a", "r");
	if(!fp) return 0;
	if( fread(buf, 4, 1, fp)!=1 ) return 0;
	if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0;
	fclose(fp);
	printf("Stage 4 clear!\n");	

	// network
	int sd, cd;
	struct sockaddr_in saddr, caddr;
	sd = socket(AF_INET, SOCK_STREAM, 0);
	if(sd == -1){
		printf("socket error, tell admin\n");
		return 0;
	}
	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = INADDR_ANY;
	saddr.sin_port = htons( atoi(argv['C']) );
	if(bind(sd, (struct sockaddr*)&saddr, sizeof(saddr)) < 0){
		printf("bind error, use another port\n");
    		return 1;
	}
	listen(sd, 1);
	int c = sizeof(struct sockaddr_in);
	cd = accept(sd, (struct sockaddr *)&caddr, (socklen_t*)&c);
	if(cd < 0){
		printf("accept error, tell admin\n");
		return 0;
	}
	if( recv(cd, buf, 4, 0) != 4 ) return 0;
	if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0;
	printf("Stage 5 clear!\n");

	// here's your flag
	system("/bin/cat flag");	
	return 0;
}
```
그냥 원하는거 맞춰서 넣어주면 된다.

[input.py](./exploit/input.py)
![input](./img/input.png)

__Flag__ : Mommy! I learned how to pass various input in Linux :)

## leg
```
int key1(){
	asm("mov r3, pc\n");
}
```
긴 코드라 필요한 부분만 보면, key1의 리턴은 mov r3, pc 이고, pc 는 i386에 eip랑 하는 일이 같다. 
```
(gdb) disass key1
Dump of assembler code for function key1:
   0x00008cd4 <+0>:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008cd8 <+4>:	add	r11, sp, #0
   0x00008cdc <+8>:	mov	r3, pc
   0x00008ce0 <+12>:	mov	r0, r3
   0x00008ce4 <+16>:	sub	sp, r11, #0
   0x00008ce8 <+20>:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008cec <+24>:	bx	lr
```
하지만 pc의 값은 arm은 pipeline을 사용하여 돌아감으로 pc는 현 실행 명령어 다음다음 명령어를 가르킨다.<br>따라서 key1의 값은 0x00008ce4 이다.

```
int key2(){
	asm(
	"push	{r6}\n"
	"add	r6, pc, $1\n"
	"bx	r6\n"
	".code   16\n"
	"mov	r3, pc\n"
	"add	r3, $0x4\n"
	"push	{r3}\n"
	"pop	{pc}\n"
	".code	32\n"
	"pop	{r6}\n"
	);
}
```
key2도 key1과 같다. 
```
(gdb) disass key2
Dump of assembler code for function key2:
   0x00008cf0 <+0>:	push	{r11}		; (str r11, [sp, #-4]!)
   0x00008cf4 <+4>:	add	r11, sp, #0
   0x00008cf8 <+8>:	push	{r6}		; (str r6, [sp, #-4]!)
   0x00008cfc <+12>:	add	r6, pc, #1
   0x00008d00 <+16>:	bx	r6
   0x00008d04 <+20>:	mov	r3, pc
   0x00008d06 <+22>:	adds	r3, #4
   0x00008d08 <+24>:	push	{r3}
   0x00008d0a <+26>:	pop	{pc}
   0x00008d0c <+28>:	pop	{r6}		; (ldr r6, [sp], #4)
   0x00008d10 <+32>:	mov	r0, r3
   0x00008d14 <+36>:	sub	sp, r11, #0
   0x00008d18 <+40>:	pop	{r11}		; (ldr r11, [sp], #4)
   0x00008d1c <+44>:	bx	lr
```
key2 : 0x00008d08 + 4

```
int key3(){
	asm("mov r3, lr\n");
}
```
lr은 return될 주소를 가르킨다. 
```
   0x00008d7c <+64>:	bl	0x8d20 <key3>
   0x00008d80 <+68>:	mov	r3, r0
```
key3 : 0x00008d80 

따라서 답은 108400다.

![leg](./img/leg.png)

__Flag__ : My daddy has a lot of ARMv5te muscle!

